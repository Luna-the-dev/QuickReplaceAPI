using System.Diagnostics;
using System.Text;

namespace TextReplaceAPI.Tests.Common
{
    internal class FileComparer
    {
        const int BYTES_TO_READ = sizeof(Int64);

        /// <summary>
        /// Checks to see if two files are the same.
        /// </summary>
        /// <param name="firstPath"></param>
        /// <param name="secondPath"></param>
        /// <returns>Returns true if both files are the same.</returns>
        /// <exception cref="FileNotFoundException"></exception>
        public static bool FilesAreEqual(string firstPath, string secondPath)
        {
            if (File.Exists(firstPath) == false)
            {
                throw new FileNotFoundException($"File \"{firstPath}\" does not exist.");
            }

            if (File.Exists(secondPath) == false)
            {
                throw new FileNotFoundException($"File \"{secondPath}\" does not exist.");
            }

            try
            {
                var first = new FileInfo(firstPath);
                var second = new FileInfo(secondPath);

                if (first.Length != second.Length)
                {
                    return false;
                }

                if (string.Equals(first.FullName, second.FullName, StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }

                int iterations = (int)Math.Ceiling((double)first.Length / BYTES_TO_READ);

                using FileStream fs1 = first.OpenRead();
                using FileStream fs2 = second.OpenRead();

                byte[] one = new byte[BYTES_TO_READ];
                byte[] two = new byte[BYTES_TO_READ];

                for (int i = 0; i < iterations; i++)
                {
                    fs1.Read(one, 0, BYTES_TO_READ);
                    fs2.Read(two, 0, BYTES_TO_READ);

                    if (BitConverter.ToInt64(one, 0) != BitConverter.ToInt64(two, 0))
                    {
                        return false;
                    }
                }

                return true;
            }
            catch (Exception e)
            {
                Debug.WriteLine(e);
                return false;
            }
        }

        /// <summary>
        /// Checks to see if two .xlsx or .docx files generated by OpenXml are the same.
        /// Note: both files are loaded into memory, so only use this for testing on small/medium size excel files
        /// </summary>
        /// <param name="firstPath"></param>
        /// <param name="secondPath"></param>
        /// <returns>Returns true if both .xlsx or .docx files are the same.</returns>
        /// <exception cref="NotSupportedException"></exception>
        /// <exception cref="FileNotFoundException"></exception>
        public static bool FilesAreEqual_OpenXml(string firstPath, string secondPath)
        {
            if ((Path.GetExtension(firstPath) != ".xlsx" || Path.GetExtension(secondPath) != ".xlsx") &&
                    (Path.GetExtension(firstPath) != ".docx" || Path.GetExtension(secondPath) != ".docx"))
            {
                throw new NotSupportedException("This method is designed only to compare .xlsx with .xlsx or .docx with .docx.");
            }

            if (File.Exists(firstPath) == false)
            {
                throw new FileNotFoundException($"File \"{firstPath}\" does not exist.");
            }

            if (File.Exists(secondPath) == false)
            {
                throw new FileNotFoundException($"File \"{secondPath}\" does not exist.");
            }

            try
            {
                var firstUnzippedPath = string.Format("{0}/{1}",
                                                      Path.GetDirectoryName(firstPath),
                                                      Path.GetFileNameWithoutExtension(firstPath));
                var secondUnzippedPath = string.Format("{0}/{1}",
                                                       Path.GetDirectoryName(secondPath),
                                                       Path.GetFileNameWithoutExtension(secondPath));

                // delete unzipped paths if they already existed
                if (Directory.Exists(firstUnzippedPath))
                {
                    Directory.Delete(firstUnzippedPath, true);
                }

                if (Directory.Exists(secondUnzippedPath))
                {
                    Directory.Delete(secondUnzippedPath, true);
                }

                // extract the .xlsx or .docx files to compare the relevant .xml files within
                System.IO.Compression.ZipFile.ExtractToDirectory(firstPath, firstUnzippedPath);
                System.IO.Compression.ZipFile.ExtractToDirectory(secondPath, secondUnzippedPath);

                var firstContentsDirectory = "";
                var secondContentsDirectory = "";

                // traverse to the main contents of the files to compare them
                if (Path.GetExtension(firstPath) == ".xlsx")
                {
                    firstContentsDirectory = firstUnzippedPath + "/xl";
                    secondContentsDirectory = secondUnzippedPath + "/xl";
                }
                else
                {
                    firstContentsDirectory = firstUnzippedPath + "/word";
                    secondContentsDirectory = secondUnzippedPath + "/word";
                }

                // compare files in the ./xl/ or ./docx/ directory
                if (CompareFilesInDirectory(firstContentsDirectory, secondContentsDirectory) == false)
                {
                    Debug.WriteLine("files in ./xl/ or ./docx/ directory don't match");
                    Directory.Delete(firstUnzippedPath, true);
                    Directory.Delete(secondUnzippedPath, true);
                    return false;
                }

                var firstDirectoriesList = new DirectoryInfo(firstContentsDirectory).GetDirectories();
                var secondDirectoriesList = new DirectoryInfo(secondContentsDirectory).GetDirectories();

                // if one ./xl/ or ./docx/ has more subdirectories than the other, return false
                if (firstDirectoriesList.Length != secondDirectoriesList.Length)
                {
                    Debug.WriteLine("subdirectory counts in ./xl/ or ./docx/ aren't equal");
                    Directory.Delete(firstUnzippedPath, true);
                    Directory.Delete(secondUnzippedPath, true);
                    return false;
                }

                // combine the two lists of directories into one
                var directories = firstDirectoriesList.Zip(secondDirectoriesList, (f, s) => new { First = f, Second = s });

                // compare all subdirectories of /xl/
                foreach (var directory in directories)
                {
                    if (directory.First.Name == "._rels" || directory.Second.Name == "_rels")
                    {
                        continue;
                    }

                    if (CompareFilesInDirectory(directory.First.FullName, directory.Second.FullName) == false)
                    {
                        Debug.WriteLine($"files do not match: {directory.First.FullName} and {directory.Second.FullName}");
                        Directory.Delete(firstUnzippedPath, true);
                        Directory.Delete(secondUnzippedPath, true);
                        return false;
                    }
                }

                // cleanup the unzipped .xlsx or .docx directories
                Directory.Delete(firstUnzippedPath, true);
                Directory.Delete(secondUnzippedPath, true);

                return true;
            }
            catch (Exception e)
            {
                Debug.WriteLine(e);
                return false;
            }
        }

        /// <summary>
        /// Iterates through two directories and checks to see if each file within the first
        /// directory is the same as the corresponding file in the second directory.
        /// </summary>
        /// <param name="firstDirectory"></param>
        /// <param name="secondDirectory"></param>
        /// <returns>
        /// Returns true if each file in the first directory is the same as
        /// the corresponding file in the second directory
        /// </returns>
        static public bool CompareFilesInDirectory(string firstDirectory, string secondDirectory)
        {
            try
            {
                var firstFilesList = new DirectoryInfo(firstDirectory).GetFiles();
                var secondFilesList = new DirectoryInfo(secondDirectory).GetFiles();

                // if one directory has more files than the other, return false
                if (firstFilesList.Length != secondFilesList.Length)
                {
                    return false;
                }

                // combine the two lists of files into one
                var files = firstFilesList.Zip(secondFilesList, (f, s) => new { First = f, Second = s });

                foreach (var file in files)
                {
                    if (FilesAreEqual(file.First.FullName, file.Second.FullName) == false)
                    {
                        Debug.WriteLine($"files that dont match: {file.First.FullName}\t{file.Second.FullName}");
                        return false;
                    }
                }

                return true;
            }
            catch (DirectoryNotFoundException)
            {
                Debug.WriteLine("CompareFilesInDirectory(): Directory not found...");
                Debug.WriteLine($"{firstDirectory} or {secondDirectory}");
                Debug.WriteLine("Returning true anyways");
                return true;
            }
            catch (Exception e)
            {
                Debug.WriteLine(e);
                return false;
            }
        }

        /// <summary>
        /// Converts a byte array's data to a string, with each byte seperated by a comma.
        /// </summary>
        /// <param name="bytes"></param>
        /// <returns>String containing the byte array's data, seperated by commas</returns>
        static private string StringifyByteArray(byte[] bytes)
        {
            var sb = new StringBuilder();
            foreach (var b in bytes)
            {
                sb.Append(b + ", ");
            }
            
            return sb.ToString();
        }
    }
}
